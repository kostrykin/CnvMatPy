# cnvmats.py

This repository contains the `cnvmats` Python 2.7 module. It provides a few classes, whose instances represent convolution and/or correlation matrices, like ![A](http://quicklatex.com/cache3/ql_56db631243bb90a9551347ff54d9916b_l3.png) and ![X](http://quicklatex.com/cache3/ql_70c8395e6ecd291a1e7887bd5eef6e31_l3.png) in ![Ax = Xa = a*x](http://quicklatex.com/cache3/ql_5a5bb1356fc622887312a4e7c4e8bfae_l3.png), respectively. Besides of being multiplied with numpy arrays, the matrices ![A](http://quicklatex.com/cache3/ql_56db631243bb90a9551347ff54d9916b_l3.png) and ![X](http://quicklatex.com/cache3/ql_70c8395e6ecd291a1e7887bd5eef6e31_l3.png) can be **transposed** using their `tp` method.

The matrices are instantiated by the `cnvmats.cnvmat` function. This function has a `mode` argument that can be set to either `valid`, `full` or `circ`. The convolution is implemented in frequency domain. The point is that the matrix that `cnvmats.cnvmat` returns **never actually computes the whole matrix**, unless it is told so to do using its `toarray` method.

Here is a simple example that loads an image and applies a box-filter:

```python
import numpy as np
import cv2
import cnvmats

sa = (30,30)
x = cv2.imread('lena.png', 0)
a = np.ones(sa) / np.prod(sa)
A = cnvmat(a, x.shape, 'valid')
y = (A*x).real
```

The `cnvmats_test.py` file contains tests and further examples.

![modes](https://github.com/kostrykin/CnvMatPy/blob/master/cnvmats_show.png?raw=true "modes")

The above image was generated by the `cnvmats_show.py` script.

Dependencies:

- NumPy

### Restrictions

- The matrices' `__mult__` operator is currently only implemented for multiplication with `numpy.array` objects, not for other matrices from `cnvmats` package.

### Attribution

The LaTeX on this page is rendered using the services from [QuickLaTeX.com](http://quicklatex.com).
